{"version":3,"file":"index.js","sources":["src/actions.js","src/types/keyValue/keyValue.middleware.js","src/selectors.js","src/types/simpleObject/simpleObject.middleware.js","src/types/simpleObject/simpleObject.selectors.js","src/reducer.js","src/index.js"],"sourcesContent":["const scope = action => `@@krf/${action.toUpperCase()}`\n\nconst getPrefix = prefix => name => `${prefix ? '>' : ''}${prefix}>${name}`\n\nexport const SET = prefix => name => scope(`SET${getPrefix(prefix)(name)}`)\nexport const set = prefix => name => payload => ({ type: SET(prefix)(name), payload })\n\nexport const RESET = prefix => name => scope(`RESET${getPrefix(prefix)(name)}`)\nexport const reset = prefix => name => () => ({ type: RESET(prefix)(name) })\n\nexport const ADD = prefix => name => scope(`ADD${getPrefix(prefix)(name)}`)\nexport const add = prefix => name => payload => ({ type: ADD(prefix)(name), payload })\n\nexport const UPDATE = prefix => name => scope(`UPDATE${getPrefix(prefix)(name)}`)\nexport const update = prefix => name => payload => ({ type: UPDATE(prefix)(name), payload })\n\nexport const REMOVE = prefix => name => scope(`REMOVE${getPrefix(prefix)(name)}`)\nexport const remove = prefix => name => key => ({ type: REMOVE(prefix)(name), payload: key })\n\nexport const ADD_OR_UPDATE = prefix => name => scope(`ADD_OR_UPDATE${getPrefix(prefix)(name)}`)\nexport const addOrUpdate = prefix => name => payload => ({ type: ADD_OR_UPDATE(prefix)(name), payload })\n\nexport const REPLACE = prefix => name => scope(`REPLACE${getPrefix(prefix)(name)}`)\nexport const replace = prefix => name => payload => ({ type: REPLACE(prefix)(name), payload })\n\nexport const ORDER_BY = prefix => name => scope(`ORDER_BY${getPrefix(prefix)(name)}`)\nexport const orderBy = prefix => name => payload => ({ type: ORDER_BY(prefix)(name), payload })\n","import { keyBy, without, uniq, omit, orderBy, get, isObjectLike, isString, flatten } from 'lodash'\nimport { SET, ADD, UPDATE, REMOVE, RESET, ADD_OR_UPDATE, REPLACE, ORDER_BY } from './keyValue.actions'\n\nexport const initState = { data: {}, keys: [], array: [], initialized: false }\n\nconst keyAlreadyExists =\n  state => (key, instanceKey) => state.array.find(o => o[key] === instanceKey)\n\nconst set = (key, payload) => ({\n  data: keyBy(payload, key),\n  keys: uniq(payload.map(element => element[key])),\n  array: payload,\n  initialized: true,\n})\n\nconst add = (key, state, payload) => {\n  let array\n  const instanceKey = payload[key]\n  if (!keyAlreadyExists(state)(key, instanceKey)) {\n    array = [...state.array, payload]\n  } else {\n    array = state.array.map(o => (o[key] === instanceKey ? payload : o))\n  }\n\n  return {\n    ...state,\n    data: { ...state.data, [instanceKey]: payload },\n    keys: uniq([...state.keys, instanceKey]),\n    array,\n    initialized: true,\n  }\n}\n\nconst update = (key, state, payload) => {\n  const instanceKey = payload[key]\n\n  return {\n    ...state,\n    data: { ...state.data, [instanceKey]: { ...state.data[instanceKey], ...payload } },\n    array: state.array.map(o => (o[key] === instanceKey ? { ...o, ...payload } : o)),\n  }\n}\n\nconst replace = (key, state, payload) => {\n  const instanceKey = payload[key]\n\n  return {\n    ...state,\n    data: { ...state.data, [instanceKey]: payload },\n    array: state.array.map(o => (o[key] === instanceKey ? payload : o)),\n  }\n}\n\nconst defaultState =\n  (key, defaultData) => (defaultData !== undefined ? set(key, defaultData) : initState)\n\nconst reducer = key => prefix => name => defaultData =>\n  (state = defaultState(key, defaultData), { type, payload } = {}) => {\n    switch (type) {\n      case SET(prefix)(name): return set(key, payload)\n      case ADD(prefix)(name): return add(key, state, payload)\n      case ADD_OR_UPDATE(prefix)(name): {\n        if (!keyAlreadyExists(state)(key, payload[key])) return add(key, state, payload)\n        return update(key, state, payload)\n      }\n      case UPDATE(prefix)(name): {\n        if (!keyAlreadyExists(state)(key, payload[key])) return state\n        return update(key, state, payload)\n      }\n      case REPLACE(prefix)(name): {\n        if (!keyAlreadyExists(state)(key, payload[key])) return state\n        return replace(key, state, payload)\n      }\n      case ORDER_BY(prefix)(name): {\n        let by = payload\n        let orders = 'asc'\n        if (isObjectLike(payload)) {\n          by = payload.by\n          orders = payload.desc ? 'desc' : 'asc'\n        }\n        const arraySorted = orderBy(\n          state.array,\n          isString(by) ? p => get(p, by) : by,\n          orders,\n        )\n        return {\n          ...state,\n          array: arraySorted,\n          keys: uniq(arraySorted.map(element => element[key])),\n        }\n      }\n      case REMOVE(prefix)(name): {\n        const removeIds = flatten([payload])\n        return {\n          ...state,\n          data: omit(state.data, removeIds),\n          keys: without(state.keys, ...removeIds),\n          array: state.array ? state.array.filter(o => !removeIds.includes(o[key])) : [],\n        }\n      }\n      case RESET(prefix)(name):\n        return defaultState(key, defaultData)\n      default:\n        return state\n    }\n  }\n\nexport default key => prefix => name => defaultData => (ctx = {}) => ({\n  ...ctx,\n  state: reducer(key)(prefix)(name)(defaultData)(ctx.state, ctx.action),\n})\n","import { at } from 'lodash'\n\nexport const getState = options => (state) => {\n  let subState = state\n  const { name, path } = options\n\n  if (path !== undefined && path.length > 0) subState = at(state, path)[0]\n\n  return subState[name]\n}\n\nconst getFactory = key => options => state => getState(options)(state)[key]\nexport const getKeys = getFactory('keys')\nexport const getAsArray = getFactory('array')\nexport const getLength = options => state => getKeys(options)(state).length\nexport const isInitialized = getFactory('initialized')\n\nconst getData = options => getFactory('data')(options)\nexport const get = options => keys => (state) => {\n  const data = getData(options)(state)\n  // All data\n  if (!keys) return data\n  // By keys\n  if (Array.isArray(keys)) return keys.map(k => data[k])\n  // By key\n  return data[keys]\n}\n\nexport const getBy = options => (propertyPath, values) => (state) => {\n  const data = getAsArray(options)(state)\n  if (Array.isArray(values)) return data.filter(d => values.includes(at(d, propertyPath)[0]))\n  return data.filter(d => values === at(d, propertyPath)[0])\n}\n\nexport const hasKey = options => key => (state) => {\n  const keys = getKeys(options)(state)\n\n  return keys.includes(key)\n}\n","import { SET, RESET, UPDATE } from './simpleObject.actions'\n\nexport const initState = {}\nconst defaultState = defaultData => (defaultData !== undefined ? defaultData : initState)\n\nconst reducer = (/* key */) => prefix => name => defaultData =>\n  (state = defaultState(defaultData), { type, payload } = {}) => {\n    switch (type) {\n      case SET(prefix)(name):\n        return payload\n      case UPDATE(prefix)(name):\n        return { ...state, ...payload }\n      case RESET(prefix)(name):\n        return defaultState(defaultData)\n      default:\n        return state\n    }\n  }\n\nexport default key => prefix => name => defaultData => (ctx = {}) => ({\n  ...ctx,\n  state: reducer(key)(prefix)(name)(defaultData)(ctx.state, ctx.action),\n})\n","import { initState } from './simpleObject.middleware'\nimport { getState } from '../../selectors'\n\nexport const get = options => () => state => getState(options)(state)\n\nexport const isInitialized = options => (state) => {\n  if (options.defaultData !== undefined) return getState(options)(state) !== options.defaultData\n  return get(options)()(state) !== initState\n}\n","export default middlewares => key => prefix => name => defaultData =>\n  (state, { type = 'UNKNOWN', payload } = {}) => {\n    let prevCtx = { state, action: { type, payload } }\n\n    // middlewares to call (in right order)\n    const middlewaresToCall = [\n      // injected by user\n      ...(middlewares.pre || []),\n      // injected by types selection (reducer type)\n      ...(middlewares.engine || []),\n      // injected by user\n      ...(middlewares.post || []),\n    ]\n\n    middlewaresToCall\n      // pass parameters\n      .map(middleware => middleware(key)(prefix)(name)(defaultData))\n      // call middlewares\n      .forEach((middleware) => {\n        prevCtx = middleware(prevCtx)\n      })\n\n    // returns last results to Redux\n    return prevCtx.state\n  }\n","import * as types from './types'\nimport reducer from './reducer'\n\nconst getWrappedStore = (middlewares = {}) => (options) => {\n  const { key, type = 'keyValue', prefix = '', name, defaultData } = options\n  const typeConfig = types[type]\n\n  return Object.assign(\n    reducer({ ...middlewares, engine: typeConfig.middlewares })(key)(prefix)(name)(defaultData),\n\n    // type (debug purpose)\n    { krfType: type },\n\n    // actions\n    ...Object.keys(typeConfig.actions).map(k => ({ [k]: typeConfig.actions[k](prefix)(name) })),\n\n    // selectors\n    ...Object.keys(typeConfig.selectors).map(k => ({ [k]: typeConfig.selectors[k](options) })),\n  )\n}\n\n// error :( - not a middleware nor an option parameter\nconst error = () => { throw Error('parameter is not a middleware configuration, nor a factory option object.') }\n\n// params checkers\nconst isMiddleware = params => params.engine || params.pre || params.post\nconst isOptions = params => (!!params.name) || (typeof params === 'string')\n\n// eslint-disable-next-line consistent-return\nconst factory = (forcedOptions = {}) => (params) => {\n  // no param : error\n  if (params === null || params === undefined) error()\n\n  // middleware case\n  if (isMiddleware(params)) {\n    return options => getWrappedStore(params)({ ...options, ...forcedOptions })\n  }\n  // no middleware case\n  if (isOptions(params)) {\n    if (typeof params === 'string') return getWrappedStore()({ name: params, ...forcedOptions })\n    return getWrappedStore()({ ...params, ...forcedOptions })\n  }\n\n  // not a valid param\n  error()\n}\n\nexport const simpleObject = factory({ type: 'simpleObject' })\nexport const keyValue = factory({ type: 'keyValue' })\n\n// default public factory\nexport default factory()\n"],"names":["scope","action","toUpperCase","getPrefix","prefix","name","SET","set","type","payload","RESET","reset","ADD","UPDATE","update","REMOVE","ADD_OR_UPDATE","REPLACE","ORDER_BY","key","initState","data","keys","array","initialized","keyAlreadyExists","instanceKey","state","find","o","keyBy","uniq","map","element","add","replace","defaultState","defaultData","undefined","reducer","by","orders","isObjectLike","desc","arraySorted","orderBy","isString","get","p","removeIds","flatten","omit","without","filter","includes","getState","subState","options","path","length","at","getFactory","getKeys","getAsArray","isInitialized","getData","ctx","Array","isArray","k","propertyPath","values","d","prevCtx","middlewares","pre","engine","post","middleware","forEach","getWrappedStore","typeConfig","types","Object","assign","krfType","actions","selectors","error","Error","isMiddleware","params","isOptions","factory","forcedOptions","simpleObject","keyValue"],"mappings":"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"}